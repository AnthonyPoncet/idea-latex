{
  parserClass               = "mobi.hsz.idea.latex.parser.LatexParser"

  extends                   = "mobi.hsz.idea.latex.psi.LatexElementImpl"

  psiClassPrefix            = "Latex"
  psiImplClassSuffix        = "Impl"
  psiPackage                = "mobi.hsz.idea.latex.psi"
  psiImplPackage            = "mobi.hsz.idea.latex.psi.impl"

  elementTypeHolderClass    = "mobi.hsz.idea.latex.psi.LatexTypes"
  elementTypeClass          = "mobi.hsz.idea.latex.psi.LatexElementType"
  tokenTypeClass            = "mobi.hsz.idea.latex.psi.LatexTokenType"

  tokens = [
    LBRACE                  = "{"
    RBRACE                  = "}"
    LBRACKET                = "["
    RBRACKET                = "]"
    LPAREN                  = "("
    RPAREN                  = ")"
    COMMA                   = ","
    COLON                   = ":"
    ASTERISK                = "*"
    SLASH                   = '\'
    LINE_BREAK              = '\\'


    INSTRUCTION = "regexp:\\[a-zA-Z]+"
    IDENTIFIER              = "regexp:[a-zA-Z]+"
    ARGUMENT                = "regexp:\b[\p{L}\w ]+\b|\\\W"
    COMMENT                 = "regexp:%.*"

    SPECIAL                 = "regexp:[\S]"
    CRLF                    = "regexp:[\s\r\n]+"
  ]

  mixin("INSTRUCTION")      = "mobi.hsz.idea.latex.psi.impl.LatexInstructionBaseImpl"
//  name("INSTRUCTION.*")     = "instruction"
//  name(".*expr")           = "entry"
}


latexFile                       ::= item_ *
private item_                   ::= !<<eof>> expr *

private expr                    ::= text_expr
                                  | group_expr +
                                  | argument_expr
                                  | instruction_expr
                                  | special_expr
                                  | TEXT
                                  | CRLF
private expr_inside             ::= argument_expr
                                  | group_expr +
                                  | instruction_expr
                                  | special_expr
private instruction_            ::= INSTRUCTION_BEGIN
                                  | INSTRUCTION_END
                                  | INSTRUCTION

INSTRUCTION_BEGIN               ::= "\\begin"
INSTRUCTION_END                 ::= "\\end"

private argument_expr           ::= (ARGUMENT | IDENTIFIER) (special_expr + ( ARGUMENT | IDENTIFIER | instruction_expr | CRLF ) ) * { pin(".*") = 1 }
private group_expr              ::= expr_list_bracket | expr_list_brace | expr_list_paren
instruction_expr                ::= instruction_ ASTERISK ? group_expr *
private text_expr               ::= ( special_expr * ARGUMENT special_expr * CRLF * ) +
private special_expr            ::= SPECIAL | COLON | COMMA | LINE_BREAK

private meta expr_list_bracket  ::= LBRACKET <<sequence expr_inside special_expr>> ? RBRACKET { pin(".*") = 1 }
private meta expr_list_brace    ::= LBRACE   <<sequence expr_inside special_expr>> ? RBRACE   { pin(".*") = 1 }
private meta expr_list_paren    ::= LPAREN   <<sequence expr_inside special_expr>> ? RPAREN   { pin(".*") = 1 }
private meta sequence           ::= <<p>> + (<<q>> <<p>>) * { pin(".*") = 1 }
